<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>data-dictionary</title>

<link rel="stylesheet" href="../../style.css" type="text/css" />

<link rel="stylesheet" href="../../local.css" type="text/css" />





</head>
<body>

<div class="page">

<div class="pageheader">
<div class="header">
<span>
<span class="parentlinks">

<a href="../../">CCNQ3</a>/ 

<a href="../">doc</a>/ 

</span>
<span class="title">
data-dictionary

</span>
</span>

</div>





</div>



<div id="pagebody">

<div id="content">
<p>This document describes the configuration parameters for ccnq3.</p>

<p>In this document the term <em>URI of database</em> signifies a URI of some CouchDB database,
and is always a string.
These URIs might contain authentication usernames and passwords.</p>

<h1>provisioning database</h1>

<p>The provisioning database contains the master copy of all provisioning information
for an entire system.
It contains different types of records, which can be identified by their "type" field.
The type is also the first part of the records' identifier, to avoid collisions.</p>

<h2>host (aka config) provisioning records</h2>

<p>The local configuration file for a host, normally found in
<code>/etc/ccnq3/host.json</code>, is a copy of the <code>host</code> record for that
specific server as found in the master CouchDB provisioning database.</p>

<p>There must be exactly one "host" record for each server in the system.
Servers are identified by there (arbitrary) Full Qualified Domain Name (FQDN).</p>

<p>Most changes in this type of records might require you to:</p>

<ul>
<li><p>either restart the ccnq3 processes to apply the changes:</p>

<pre><code>/etc/init.d/ccnq3 restart
</code></pre>

<p>(This should be sufficient in most cases.)</p></li>
<li><p>in some cases reinstall the ccnq3 package:</p>

<pre><code>aptitude reinstall ccnq3
</code></pre>

<p>This is especially true when adding an application, so that
the proper dependencies might be installed for the new application.</p></li>
</ul>


<p>However this does not apply to commands (such as the ones in "sip_commands"),
which are executed immediately.</p>

<p>Please note that restarting, reinstalling, or submitting commands in a lot of
cases will cause calls to disconnect. These operations are best used during
dedicated maintenance windows and should be avoided during production use.</p>

<p>Currently the main freeswitch, opensips, and medaproxy processes are not started by ccnq3.
These processes might be controlled using their respective /etc/init.d/ scripts.</p>

<p>Developper note: "host" records are referred to as the "config" record inside most applications.</p>

<h3>Common section (host provisioning record)</h3>

<p>All the fields in this section are pre-populated by the various scripts.
There is no reason to change them after the initial installation of a server.
Only the "applications" array will need to be expanded.
(This can be easily done using the web portal.)</p>

<p>Caveat: provisioning.host_couchdb_uri might need to be fixed if the system cannot guess
your installation.</p>

<ul>
<li><p><code>_id</code>: type+":"+host</p></li>
<li><p><code>account</code>: ""    (the empty string)</p></li>
<li><p>`updated_at: integer, update timestamp in ms [required]</p>

<p><code>new Date().getTime()</code>  for example</p></li>
<li><p><code>type</code>: "host"</p></li>
<li><p><code>host</code>: string; hostname, preferably FQDN (must match what the "hostname" command returns)</p></li>
<li><p><code>interfaces</code>: {} of {}, fields:</p>

<ul>
<li><code>ipv4</code>: IP (if interface supports v4)</li>
<li><code>ipv6</code>: IP (if interface supports v6)</li>
</ul>


<p>The key of the records must be unique, so they cannot just be the interface's name,
since an interface may have multiple v4 or v6 IP addresses.</p>

<p>The key <code>primary</code> has a special meaning (see next item).</p></li>
<li><p><code>interfaces.primary.ipv4</code>,
<code>interfaces.primary.ipv6</code></p>

<p>If present, these are selected as the addresses for the host itself.
Otherwise a random non-private IPv4 address is selected, and a
random IPv6 address is selected, from the ones present in the
"interfaces" records.</p></li>
</ul>


<p>Changing any of the following settings would require to restart the matching
services, since configuration is read (in most cases) once at startup.</p>

<ul>
<li><p><code>admin</code>:   (only present for bootstrap-system hosts normally; there's no reason to modify these)</p>

<ul>
<li><code>couchdb_uri</code>: server admin URI</li>
<li><code>system</code>: true   (indicates this host is the one that should do system updates)</li>
</ul>
</li>
<li><p><code>applications</code>: [] of strings, list of applications that need to be installed</p>

<p>These are simply relative paths to the matching "package" for that application.
To apply changes to the list of applications, you must <code>aptitude reinstall ccnq3</code> on the host.</p>

<p>Example:</p>

<pre><code>[ "applications/host", "applications/traces", "applications/freeswitch" ]
</code></pre></li>
<li><p><code>usercode</code>:</p>

<ul>
<li><code>couchdb_uri</code>: URI of the usercode database (with database admin authentication) [used by couchapps to install their applications]</li>
</ul>
</li>
<li><p><code>provisioning</code>:</p>

<ul>
<li><p><code>couchdb_uri</code>: URI of the provisioning database (with database admin authentication) [used by couchapps apps to insert new applications]</p>

<p>Normally only present on a manager host (and only used by installation scripts)</p></li>
<li><p><code>host_couchdb_uri</code>: URI of the provisioning database (read-only) [allows access to the main provisioning database from any host]</p>

<p>This URI is used as the source for replication of the provisioning database onto a non-manager host
Replication will work better if this URI points directly to CouchDB (rather than a reverse proxy, for example).</p>

<p>This URI is also used by ccnq3_config to locate the host's configuration; if it is not present only the local (file-based) configuration will be used.</p></li>
<li><p><code>local_couchdb_uri</code>: URI of a local replica of the provisioning database [used by local applications such as opensips]</p>

<p>Generally <code>http://127.0.0.1:5984/provisioning</code> [no authentication to keep things faster]</p>

<p>Realtime (call-handling) applications should only rely on this database as their primary source.</p>

<p>Must have db admin access to the database (so that applications can push their design documents).</p></li>
</ul>
</li>
<li><p><code>install</code>: (normally not defined)</p>

<p>This feature is used to force re-installation of the corresponding databases (for example to change the URI)</p>

<ul>
<li><code>usercode</code>:

<ul>
<li><code>couchdb_uri</code></li>
</ul>
</li>
<li><code>provisioning</code>:

<ul>
<li><code>couchdb_uri</code></li>
</ul>
</li>
<li><code>users</code>:

<ul>
<li><code>couchdb_uri</code></li>
</ul>
</li>
</ul>
</li>
</ul>


<h3>Specific to hosts running FreeSwitch</h3>

<p>To add a FreeSwitch host:</p>

<ol>
<li><p>Configure the fields in this section</p>

<p>(You'll need to configure at least <code>sip_domain_name</code>.)</p>

<p>(You'll need to configure one <code>sip_profiles[]</code> in order to be able to place calls.)</p></li>
<li><p>Add <code>applications/freeswitch</code> to the applications field [and restart ccnq3]</p></li>
</ol>


<p>Configuration options:</p>

<ul>
<li><p><code>sip_domain_name</code>:  string (required); FQDN accepted by the server</p>

<p>This should be the "cluster name" for servers running similar
configurations. This is used by applications/dns to create
SRV records for these services. This is also used by applications/opensips
to create gateway entries for the egress_gwid in those domains/clusters.
Finally, this is the domain name accepted by OpenSIPS servers in that cluster.</p></li>
<li><p>rtp_ip: local IP to bind to for RTP [default: "auto"]</p></li>
<li>cdr_aggregate_uri: URI where the local CDRs should be replicated to [no default]
  Note: must contain authentication (for the local host).</li>
<li><p>sip_profiles: {} of profiles descriptions:</p>

<ul>
<li><p>sip_profiles[profile_name]:</p></li>
<li><p>Sofia data</p>

<ul>
<li>template: sofia template name (e.g. "sbc-media", "sbc-nomedia")</li>
</ul>
</li>
<li><p>For the "sbc*" types, we need:</p>

<ul>
<li>ingress_sip_ip: which IP (v4,v6) to bind for ingress processing</li>
<li>ingress_sip_port: which port to bind for ingress processing [in the range 5060 to 5299]</li>
<li>ingress_acl: [] of CIDR records "ip/masklen" source IPs allowed for ingress processing</li>
<li>egress_sip_ip: which IP (v4,v6) to bind for egress processing [default: ingress_sip_ip]</li>
<li>egress_sip_port: which port to bind for egress processing [default: 10000+ingress_sip_port; in the range 15060 to 15299]</li>
<li>egress_acl: [] of CIDR records "ip/masklen" source IPs allowed for the egress processing</li>
<li>egress_gwid: integer, optional; a (unique) gateway id to be used in routing rules</li>
</ul>


<p>Note: port numbers must be in the range 5060 to 5299 or 15060 to 15299 to be compatible with the "traces" application.</p>

<p>Note: look in doc/doc/port-numbers.mdwn for port numbers conventions.</p>

<p>Note: egress_gwid must be unique amongst all gateway IDs, including the ones in "gateway"-type records.</p></li>
<li><p>Dialplan data</p>

<ul>
<li>handler: dialplan template name (e.g. "client-sbc", "voicemail")</li>
<li>egress_target: domain where to send egress calls</li>
</ul>
</li>
<li><p>For handler="client-sbc"</p>

<ul>
<li>type: dialplan profile type (e.g. "usa", "france")</li>
<li>send_call_to: where to send the calls ("socket", "bridge") [default: "socket"]</li>
<li>ingress_target: domain where to send ingress calls</li>
</ul>
</li>
<li><p>For handler on one of the carrier-sbc's</p>

<ul>
<li>enum_root: Carrier ENUM root for inbound routing</li>
</ul>
</li>
<li><p>For handler="voicemail"</p>

<ul>
<li>default_language: string; default voicemail language [default: this host's voicemail.default_language, see below]</li>
</ul>
</li>
</ul>


<p>  Changes (except for <em>_sip_ip and </em>_sip_port) are automatically applied.</p></li>
<li><p>sip_commands: {} of profiles commands:</p>

<ul>
<li><p>sip_commands[sofia_profile]: string
  One of:
    "start"       sofia profile  start
    "restart"     sofia profile  restart reloadxml  [required to change IP or port]
    "stop"        sofia profile  killgw</p></li>
<li><p>sip_commands.freeswitch: string
  One of:
    "reload sofia"    unload mod_sofia, load mod_sofia            [required to add a new profile]
    "pause inbound"   fsctl pause inbound
    "pause outbound"  fsctl pause outbound
    "resume inbound"  fsctl resume inbound
    "resume outbound" fsctl resume outbound</p></li>
</ul>


<p>All these commands will cause calls to drop if any is present on that profile.</p>

<p>The "sofia_profile" key is either "egress-#{profile_name}" or "ingress-#{profile_name}" so that each direction
can be restarted independently.</p>

<p>Add a command then remove it from the hash to prevent accidental misfiring of commands.</p>

<p>A special "sofia_profile" key "opensips" is used to send events to a running OpenSIPS process (rather than a
FreeSwitch sofia profile). See below for more information.</p>

<p>A special "sofia_profile" key "registrant" is used to send events to a running registrant process (rather than a
FreeSwitch sofia profile). See below for more information.</p></li>
<li><p>sip_variables: {} of global (FreeSwitch) variables; defaults to {}</p>

<p>The idea is that these can be used on a per-host basis by additional dialplans, profiles, etc.</p>

<p>These should also show up in CDRs. FIXME confirm this is the case</p></li>
</ul>


<h3>Specific to hosts running OpenSIPS.</h3>

<p>To add an OpenSIPS host:</p>

<ol>
<li>Configure the fields in this section</li>
<li>Add "applications/opensips" to the applications field [and restart ccnq3]</li>
<li>Run common/mediaproxy/install.sh to install mediaproxy FIXME still requires some work</li>
</ol>


<p>Configuration options:</p>

<ul>
<li><p>opensips_proxy:</p>

<ul>
<li>port:34340   integer, required, do not change [default]</li>
<li>hostname:"127.0.0.1"   string, required, do not change [default]</li>
<li>usrloc_uri: URI of the location database (used to save registration data)
  Note: this should be "http://127.0.0.1:5984/location" [default]</li>
<li>usrloc_aggregate_uri: URI where the location database should be replicated to [no default]
  Note: must contain authentication (for the local host).</li>
</ul>
</li>
<li><p>opensips:</p>

<ul>
<li>model: "complete", or any other model defined in common/opensips [required]</li>
<li>number_domain: string; a domain used to identify local numbers [default: "local"]
  Note: you might think of it as a dialplan name, as well.</li>
<li>listen: [] of strings "host:port" to which OpenSIPS will bind()  [default is the empty array, in which case OpenSIPS binds to all interfaces on port 5060]</li>
<li>local_ipv4: for models using it ("conference"), IP where to send all INVITE messages</li>
<li><p>local_ipv6: reserved</p></li>
<li><p>voicemail_notifier: incoming SUBSCRIBE messages are sent to this host:port or name
  Note: typically should point to the egress-* voicemail profile's NAPTR record.
  Note: if this parameter is not defined, forwarding of message waiting indication (MWI) via SUBSCRIBE and NOTIFY messages will not work.</p></li>
</ul>
</li>
<li><p>sip_commands.opensips: string
  One of:
    "reload routes"         [apply "rule" or "gateway" record changes]</p></li>
</ul>


<h3>Specific to hosts running the portal (or its back-end).</h3>

<p>To enable the portal service:</p>

<ol>
<li>configure the fields in this section</li>
<li>add "applications/portal" to the applications field [and restart ccqn3]</li>
</ol>


<p>Note: this service is enabled by default on the manager host.
You should not have to modify these settings.</p>

<ul>
<li><p>portal:</p>

<ul>
<li><p>port: integer (8765)</p></li>
<li><p>hostname:  string ("127.0.0.1")</p></li>
</ul>
</li>
<li><p>session:</p>

<ul>
<li><p>secret:  string; must be a random string</p></li>
<li><p>couchdb_uri:  public URI used to create CouchDB sessions (must end with "/_session"; no authentication in the URI)</p></li>
</ul>
</li>
<li><p>users:</p>

<ul>
<li><p>couchdb_uri: URI of the _users database (with database admin authentication)</p></li>
<li><p>replicate_uri: URI for "/_replicate" (with database admin authentication)</p></li>
<li><p>userdb_base_uri: base URI of the various users' databases (with server admin authentication, used to create the databases)</p></li>
<li><p>public_userdb_base_uri: public base URI of the various users' databases (no authentication! given out to the users)</p></li>
</ul>
</li>
<li><p>mailer:     Used as the configuration for the node-mailer package.</p>

<ul>
<li><p>sendmail: "/usr/sbin/sendmail"</p></li>
<li><p>SMTP: null</p></li>
</ul>


<p> This section is required for applications/portal and applications/voicemail to send out email notifications.</p></li>
<li><p>mail_password:</p>

<ul>
<li><p>sender_local_part: "support"; The mail_password agent will send emails from  sender_local_part+"@"+domain (where domain is the user's record's "domain" field).</p></li>
<li><p>file_base: string; a prefix used to locate the format files used by the email notifier.</p>

<p>Note: On Unix the string must finish with a slash.</p>

<p>Note: The notifier will try to append <code>portal_password.subject</code>, <code>portal_password.body</code>, <code>portal_password.html</code> to compose the email subject, text body and HTML body, respectively. If one of the files is missing, a default is used.</p>

<p>Note: The files must contain Milk templates. The template will receive in particular the following parameters:</p>

<ul>
<li>domain: the web domain used to create the account</li>
<li>name: the username</li>
<li>password: the password</li>
</ul>
</li>
</ul>
</li>
</ul>


<h3>Specific to hosts running SIP traces.</h3>

<p>To start traces:</p>

<ol>
<li>install the ccnq3-traces package</li>
<li>configure the fields in this section</li>
<li>add "applications/traces" to the applications field</li>
<li>make sure users who need to run traces have the "access:traces:" role.</li>
</ol>


<p>Installation note: this is not enabled by default even after you install the ccnq3-traces package.</p>

<ul>
<li><p>traces:</p>

<ul>
<li><p>interfaces: [] of interfaces names</p>

<p>There's no reason to modify the following parameters for traces.</p>

<ul>
<li>filesize: integer, maximum size of the sniffer traces (in ko), defaults to 10000</li>
<li>ringsize: integer, maximum number of sniffer trace files, defaults to 50</li>
<li>workdir: string, directory used to store the traces, defaults to /opt/ccnq3/traces</li>
<li>filter: string, pcap filter for traces, defaults to ports used by ccnq3 applications</li>
</ul>
</li>
<li><p>run: {} of traces to run; the index is the TCP port number; content:</p>

<ul>
<li>to_user     string; To username (destination number)</li>
<li>from_user   string; From username (calling number)</li>
<li>call_id     string; Call-ID</li>
<li>days_ago    integer; only lookup for this number of days ago (0 = today)</li>
<li>format      string; either 'pcap' or 'json'</li>
</ul>


<p>  For each entry in <code>traces.run</code>, a single-shot web server will be started on the specified port number.
  That server will send back either a JSON or a PCAP document which will contain packets found
  in the available trace files on the server.
  (Since the trace files are rotated to not exceed a given disk space, it is possible that a
  trace might not be found even though a call was placed.)</p>

<p>  The JSON ouput is an array of hash record; the records might contain the following fields:
      "frame.time"
      "ip.version"
      "ip.dsfield.dscp"
      "ip.src"
      "ip.dst"
      "ip.proto"
      "udp.srcport"
      "udp.dstport"
      "sip.Call-ID"
      "sip.Request-Line"
      "sip.Method"
      "sip.r-uri.user"
      "sip.r-uri.host"
      "sip.r-uri.port"
      "sip.Status-Line"
      "sip.Status-Code"
      "sip.to.user"
      "sip.from.user"
      "sip.From"
      "sip.To"
      "sip.contact.addr"
      "sip.User-Agent"
  To obtain the complete data use the PCAP download.</p>

<p>  Note: this type of request is highly CPU intensive for the target host.
    It is only meant as a troubleshooting tool for administrators, not as a generically available service.
    Use the cdr database to obtain per-call information as a generic service.</p></li>
</ul>
</li>
</ul>


<h3>Specific to hosts running as registrants.</h3>

<p>Related: applications/registrant</p>

<pre><code>registrant:
  local_ipv4: string, IP where to send incoming calls
  local_port: integer, port where to send incoming calls
  remote_ipv4: string, upstream registrar
  proxy_port: integer, the port for this SIP service [default: 5070]

sip_commands.registrant: string
  One of:
    "start"           Start the registrant server.
    "stop"            Stop the registrant server.

Note: registrant entries (generated by using the "registrant_password" field in global numbers records) are
      pushed into the registrant's process configuration as they appear; however they are not applied until
      a "restart" command is issued.
</code></pre>

<h4>Specific to hosts running as emergency servers.</h4>

<p>Related: applications/emergency</p>

<pre><code>emergency: {}
  Note: the configuration hash may be empty, but needs to be present for the service to start.
  proxy_port: integer, the port for this SIP service [default: 5072]

sip_commands.emergency: string
  One of:
    "start"           Start the emergency server.
    "stop"            Stop the emergency server.
</code></pre>

<h3>Specific to hosts running voicemail</h3>

<p>Voicemail is stored inside a user's own CouchDB database.
This section specifies the parameters for applications/voicemail.</p>

<pre><code>voicemail:
  userdb_base_uri: string, required; the URI prefix (including authentication for the "voicemail manager") to a user's database
  port: integer, optional; the (local) port for the voicemail ESL server [default: 7123]
  min_duration: integer, optional; the minimal duration for a voicemail fragment [default: 5]
  max_duration: integer, optional; the maximal duration for a voicemail fragment [default: 300]
  default_language: language used if none is specified in the sip_profile [default: 'en']
  number_domain: string; a domain used to identify local numbers [default: "local"]
  record_streaming: boolean; if true stream recording of messages (only available with non-encapsulated formats such as "PCMU") [default: false]
    Note: if false messages are first recorded on the local server then uploaded to the message store
  playback_streaming: boolean; if true stream playback of messages [default: true]
  format: string; voicemail message format [default: "wav"]
    Note: see http://wiki.freeswitch.org/wiki/Mod_native_file for an explanation; meaningul values would be "PCMU" or "PCMA" in most cases.
  max_parts: integer; the maximum number of segments/parts that might be recorded in a voicemail message [default: 1]
  sender: string; the email address used to send email notifications from, if none is specified for a number.
  file_base: string; a prefix used to locate the format files used by the email notifier.
    Note: On Unix this string must be terminated by a slash.
    Note: The notifier will attempt to append "voicemail_notification" or "voicemail_notification_with_attachment", then the user's language, then the component of the email message (subject, text body, or HTML body) and locate the appropriate files.
      For example, for a notification without attachment using language 'en' the following suffix will be used:
        voicemail_notification.en.subject, voicemail_notification.en.body, voicemail_notification.en.html
    Note: If present, the content of those files will be used as Milk templates. The parameters will consist of the content of the voicemail message record. Especially the following parameters are available:
      caller_id
      timestamp
    (See the "voicemail records" section below.)

  callback:  Configuration to allow users to call the number that left a voicemail message
    profile   "ingress-#{profile_name}" or "egress-#{profile_name}"
    domain    the domain name where the message should be sent to
    Note: if sending to a proxy, make sure the voicemail server has a matching endpoint record with "sbc" set to type 10 so that it is authorized to pass charging information along.
</code></pre>

<h3>Specific to hosts running the cdrs (CDR aggregation) service.</h3>

<p>To activate the CDR aggregation service:
1. Set the "aggregate.cdrs_uri" URI in the target host; make sure the CouchDB system has enough storage.
2. Add "applications/cdrs" to the list of applications on the target host. Restart the ccnq3 service to activate.
3. On each source host (hosts which are running FreeSwitch and generating global CDRs; normally your inbound-carrier and outbound-carrier SBCs), set the "cdr_aggregate_uri" to the target's host URI, with the local (source) host authentication.</p>

<p>For example
on the target host, set "aggregate.cdrs_uri" to http://admin:password@target.example.net/cdrs
on the source host, set "cdr_aggregate_uri" to http://host%40source.example.net@target.example.net/cdrs
(both URIs point to the same database, but the authentication is different).</p>

<pre><code>aggregate
  cdrs_uri: string;  URI for the database where the CDRs should be aggregated [no default]
    Note: the URI must contain authentication (it is used e.g. to create the database)
</code></pre>

<h3>Specific to hosts running the locations (Location aggregation) service.</h3>

<p>To activate the locations aggregation service:
1. Set the "aggregate.locations_uri" URI in the target host.
2. Add "applications/locations" to the list of applications on the target host. Restart the ccnq3 service to activate.
3. On each source host (hosts which are running OpenSIPS with registration), set the "opensips_proxy.usrloc_aggregate_uri" to the target's host URI, with the local (source) host authentication.</p>

<p>For example
on the target host, set "aggregate.locations_uri" to http://admin:password@target.example.net/locations
on the source host, set "opensips_proxy.usrloc_aggregate_uri" to http://host%40source.example.net@target.example.net/locations
(both URIs point to the same database, but the authentication is different).</p>

<pre><code>aggregate
  locations_uri
</code></pre>

<h3>Other data in a "host" provisioning record.</h3>

<h4>Attachments</h4>

<p>Attachments of type "application/javascript" are executed after each change.
The attachments might use any core Node.js modules.</p>

<p>FIXME test this feature</p>

<h2>domain (provisioning records)</h2>

<p>These records are normally used to populate the DNS server ("applications/dns").</p>

<p>Alternatively, if "support_alternate_domains" is enabled in the OpenSIPS configuration,
an OpenSIPS server will accept any domain listed here.
(By default only sip_domain_name is accepted.)</p>

<pre><code>_id: type+":"+domain
account: ""    (the empty string)

type:"domain"
domain: string; the name of the DNS domain
</code></pre>

<h3>ccnq3-dns service</h3>

<p>  If "applications/dns" is configured on the host, "domain" provisioning records may be used to populate DNS records.
  In this case the "account" field is optional (which can only be done on the main provisioning database).
  The following fields are available:</p>

<pre><code>ENUM: boolean; true if the domain is to be used to provide "number"-type records as a Carrier ENUM service
ttl: integer, time-to-live for the records
  Note: should be short for an ENUM domain.
admin: optional string, the contact value of the domain's SOA [default: "hostmaster."+domain]
records: [] of {}; the fields of the records are as follows:
  prefix: a prefix to the domain (local name) [optional]
  ttl: integer, individual record's ttl [overrides domain's default]
  class: "A", "NS", etc. [default: "A"] (only "IN" classes are supported)
  value: either a string (if only one value is provided, for example for A, CNAME, NS, etc.), or an array of response values.
    An array value is used for example for SRV records or NAPTR records.

  Example:
    records: [
      {class:'NS', value:'ns1.example.net.'}
      {class:'NS', value:'ns2.example.net.'}
      {prefix:'s1',value:'192.168.1.10'}
      {prefix:'_sip._udp',class:'SRV',value:[20,7,5060,"sip1.example.net."]}
      {class:"NAPTR",value:[20,10,'u','E2U+sip',"!^.*$!sip:foo@example.net!", ""]

    ]
</code></pre>

<p>  Note: "applications/dns" runs on port 53053. To allow remote hosts to access the application on port 53, install the ccnq3-dns package.</p>

<h2>account_forwarder (provisioning records)</h2>

<p>For non-trusted host that are allowed to submit P-Charge-Info, list of accounts they may submit.</p>

<pre><code>_id: type+":"+account+'@'+endpoint
account: account

type:"account_forwarder"
endpoint: endpoint
</code></pre>

<h2>endpoint (provisioning records)</h2>

<pre><code>_id: type+":"+endpoint
account: string

type:"endpoint"
endpoint: string, required; either a static IP, or a user@domain registration username
  Note: If a static IP, it must be identical to the user_ip field.
  Note: If a registration endpoint, password, ha1, and ha1b are required.

### Registration endpoint:
password: string; password used for authentication, or null if authentication not used
ha1: authentication string; hex_md5([username,challenge,password].join(":"))
ha1b: authentication string; hex_md5([username+'@'+challenge,challenge,password].join(":"))
  Note: if the "challenge" configuration parameter is empty (the default), the domain name of the To: header (for REGISTER) or From: header (for other messages) is used as the challenge. In other words: normally the challenge should be the same as the domain name used for the endpoint.

### Static endpoint:
user_ip         string  Static endpoint's IP address [required for static endpoints]
  Note: must be identical to the endpoint field if used.
user_port       integer Static endpoint's port number [optional]
disabled        boolean If true, this IP is prevented from talking to the switch.
  Note: used to build a black-list of IP addresses.

### Inbound call routing (dst_endpoint)
dest_domain     string  Override the destination domain with this value
  Note: overrides user_srv and user_via
  Note: probably obsolete
dst_disabled    boolean If true, calls towards this endpoint are blocked
strip_digit     boolean If true, remove the first digit of the destination username
user_force_mp   boolean If true, attempt to force media_proxy insertion
user_srv        string  Final user's domain (compatible with user_via)
user_via        string  If present, calls are routed via this SBC
  Note: this requires a type of SBC which has not yet been ported to ccnq3.

### Outbound call routing (src_endpoint)
dialog_timer: integer; maximum call (dialog) duration (in seconds)
outbound_route: integer; route to use for outbound calls from this endpoint; if null, per-number outbound_route is used

check_from      boolean If true, the call can only be placed if the endpoint for the number is the same as this endpoint. (Allows to restrict which caller_id is presented by an endpoint.)
dest_domain     string  Override the destination domain
sbc             integer This endpoint is an outbound SBC that sends calls to us towards a carrier.
  # Our own outbound SBCs
   1 SBC provides originator endpoint information as Sock-Info or source RURI param [outbound]
   2 SBC provides account info in P-Charge-Info (no checks) [outbound] (for example, a client-sbc)
  # Customer (outbound) SBCs
  10 SBC provides account info in P-Charge-Info, account is checked against account_forwarder [outbound]
inbound_sbc     integer This endpoint is an inbound SBC that sends calls to us from a carrier.
  # Inbound SBCs
   1 upstream SBC [inbound]

location        string  An identifier for a location record
  Note: might be overriden by the calling number's location.
outbound_route  integer An identifier for a rule record's group_id
src_disabled    boolean All outbound calls are disabled.
  Note: Use outbound_route to allow some calls (e.g. emergency) and reject others.
user_force_mp   boolean If true, attempt to force media_proxy insertion

allow_onnet     boolean Obsolete; ccnq3 is not designed for allow_onnet.
  Note: For allow_onnet to work you need to create separate "number" records for the client-side numbers so that the local OpenSIPS knows how to route them.
        Routing can be done via a CFA, pointing e.g. to the ingress side of an open (inbound) carrier-sbc.
  Note: Support for this feature might be removed at any time, do not depend on it.

emergency_domain: string
  Note: This domain is used when an outbound-proxy sends a query to an emergency server.
    The emergency server will use this domain in its 302 Redirect response to the outbound-proxy.
</code></pre>

<h2>number (provisioning records)</h2>

<pre><code>_id: type+":"+number
account: string [required]

type:"number"
number: string
  For global numbers (between a carrier-sbc and a client-sbc), formatted as "E.164-without-plus".
  For client-side local-numbers, a locally-formatted number @ the server's "number_domain".

# Global-number properties:
inbound_uri: string (URI)  a URI used by an outbound-proxy to bypass LCR and route a number directly, or an inbound Carrier SBC to route the number.
  Note: these are used to build Carrier ENUM records.
outbound_route: integer; allows to select a specific rule based on the rule's groupid

registrant_password: password for applications/registrant
  Note: you must issue a "restart" registrant command for the changes to be applied.
# FIXME: need registrant_sip_domain

# Local-number properties:
endpoint [required]
location:  string; the location identifier for this specific number (used for emergency location services)
  Note: if present, overrides the endpoint's location.
cfa:  string, URI; if present, all calls are forwarded to this URI
cfb:  string, URI; if present, busy calls are forwarded to this URI
cfda: string, URI; if present, unanswered calls are forwarded to this URI
cfnr: string, URI; if present, non-registered endpoints are forwarded to this URI
dialog_timer: integer; maximum call duration
inv_timer: integer; maximum ringback duration

privacy: boolean
  if true, a Privacy: id (mask calling number) header is added to outbound calls
asserted_number: string
  if present, a P-Asserted-Identity (Caller-ID) header is added to outbound calls

reject_anonymous: boolean
  if true, reject anonymous inbound calls
use_blacklist: boolean
  if true, reject inbound calls from the blacklist
use_whitelist: boolean
  if true, reject inbound calls from the whitelist

user_database:  string; the name of the user's own CouchDB instance (for the user who "owns" this number)
  Note: this is used by the voicemail system to locate the voicemail_settings record and record or playback voicemail
  messages.

voicemail_sender: string; the email address used to send out voicemail notifications for this number
  Note: if not present, the "voicemail.sender" configuration parameter of the host running voicemail is used.
    If neither are present, the recipient's email address is used as as stop-gap.
</code></pre>

<h2>whitelist/blacklist (provisioning records)</h2>

<p>A local number may reject or accept calls from specific numbers.</p>

<pre><code>_id: type+':'+number+'@'+calling_number
type: 'list'
number: string; a local number '@' number_domain
calling_number: string; a locally-formatted calling number

blacklist: boolean
whitelist: boolean
  must be true for the action to be taken
</code></pre>

<h2>rule (aka outbound_route) (provisioning records)</h2>

<pre><code>_id: type+":"+rule
account: ""    (the empty string)

type:"rule"
rule: host+":"+ruleid
host: the host on which OpenSIPS is running and using this rule/outbound_route
ruleid: integer; a unique ID for this rule (a sequential or random number)
  Note: the ruleid is used rather than a longer, composed key, which should have groupid, prefix, timerec, and priority.
</code></pre>

<p>The following four fields are used to select a rule.
The set of applicable rules is narrowed down as each field is applied in order.</p>

<pre><code>groupid: integer; this is the "outbound_route" of the endpoint (or of the the number, if the endpoint does not provide an "outbound_route")
  Note: although it seems OpenSIPS might support having one or more groupid for a given rule we currently do not support this option.
prefix: string; the routing (destination number) prefix (might be ""), longest-prefix match
timerec: string; a time specification
priority: integer; ruleset ordering criteria (within the groupid and prefix, for matching timerecs, the rule with the highest priority is chosen)
</code></pre>

<p>At the end of the selection process, only one rule is selected.</p>

<p>The following fields are the output of the selection process, and
are used to route the call, once a rule has been selected.</p>

<p>The gateway list indicates which gateways (either "gateway" records or "egress_gwid" sip_profiles)
are used to route the call.</p>

<pre><code>gwlist: string; a comma- and semicolon-separated list of gateways
</code></pre>

<p>The following two (output) fields are required even though they are not currently used.</p>

<pre><code>routeid: 0   (the integer 0)
attrs: ""
  The "attrs" field is present in the call CDR as "ccnq_attrs" on outbound calls.

Note: For the complete specification, see http://www.opensips.org/html/docs/modules/1.7.x/drouting.html#id293582

Note: We use sort_order = 1, meaning that inside gwlist each semicolon delimits a group of gateways; each group contains a comma-delimited list of gateways. For each call, two gateways are selected at random in each group (groups are kept in the order they appear), and the call is then sequantially forked to each gateway.
</code></pre>

<p>Note: Changes to rules and gateways are not applied automatically. Use sip_commands.opensips = "reload routes" (or the equivalent portal action) to apply the changes.</p>

<h2>emergency (provisioning records)</h2>

<p>This is currently used to implement a French emergency call router.</p>

<p>The trigger (destination) number uses the format: number#routing_data</p>

<p>  _id: type + ":" + number + "#" + routing_data
  type: "emergency"
  number: string; [for example local number "112", or global number "330112"]
  routing_data: string, matching the routing_data field of the location record.
    Note: In France this would be the INSEE code of the commune.</p>

<p>  destination: string; a target phone number expressed in the emergency_domain of the server that sent the request.
    Note: this means that the Contact URI returned in the 302 message will consist of destination@emergency_domain.</p>

<h2>gateway (provisioning records)</h2>

<pre><code>_id: type+":"+gateway
account: ""    (the empty string)

type:"gateway"
gateway: sip_domain_name+":"+gwid
sip_domain_name: the sip_domain_name of the hosts on which OpenSIPS is running and using this gateway
gwid: integer; a unique identifier for the gateway inside this sip_domain_name; used in the "gwlist" field of the "rule" record

address: the address of the gateway (IP, IP:port, etc.)

# The following fields are required even though they are not currently used.
gwtype: 0   (the integer 0)

# The following fields are required, and might be used at your convenience, although we only test the values shown here.
probe_mode: 0
strip: 0

# The following fields are optional
pri_prefix:  string
description:  string

Note: for probe_mode, the following modes are available:
  0: no probing
  1: probing only when disabled (however our scripts do not use dr_disable())
  2: probing at all times
Note: Changes are not applied automatically. Use sip_commands.opensips = "reload routes" to apply the changes.
</code></pre>

<p>Note: You do not need to create gateway records for sip_profiles which have an "egress_gwid" field, these are created automatically using the host's sip_domain_name and the egress_gwid. (They will not show up in the database but will be accessible to all the OpenSIPS hosts within that sip_domain_name.)
This feature means that you normally should not have to manually create "gateway"-type records, since all the interesting records should be created automatically.</p>

<p>Note: Changes to rules and gateways are not applied automatically. Use sip_commands.opensips = "reload routes" (or the equivalent portal action) to apply the changes.</p>

<h2>location (provisioning records)</h2>

<pre><code>_id: type+":"+location
account: string

type:"location"
location:  string; a unique identifier for this location
routing_data:  string; specific to the emergency routing system used
  Note: In France this would be the INSEE code of the commune.
</code></pre>

<h1>_users database</h1>

<p>The _users database is CouchDB's standard authentication database.</p>

<h2>user records</h2>

<pre><code>_id:"org.couchdb.user:"+name
type:"user"
name:  string; the username
password_sha:  string; sha1_hex(password+salt)
salt:  string; a random string
user_database:  string; the name of the user's own CouchDB instance
roles: [] of string
domain:  string; name of the domain used at registration time
profile:
  name:  string; user's full name
  email:  string or array of strings; email or email addresses for this user
  phone:  string; phone number for this user
  userdb_base_uri:  base URI (to which the user_database is concatenated)
  user_name: name
  user_database: user_database
</code></pre>

<p>  Notes: This is a standard CouchDB <em>users record with some additions.
  Notes: The "profile" hash is returned by a GET /u/profile.json once logged-in.
  Notes: The "name" field is normally the user's main email address (at least that's what the registration code assumes); servers and applications will also have </em>users records so that they can remotely access the main database.
  Notes: Servers should have the "host" role assigned.
  Notes: The roles hash can also be manipulated using the REST API in applications/roles.</p>

<h2>host records</h2>

<p>  _id:"org.couchd.user:"+name
  type:"user"
  name:"host@" + hostname
  password_sha
  salt
  roles: ["host"]</p>

<h1>usercode database</h1>

<p>This database should only contain design documents which are replicated into each user's private database when the user logs in.</p>

<h1>endpoint-location database</h1>

<p>The record in this database are read-only.
(In other words you should not attempt to modify them.)
They are updated by OpenSIPS.</p>

<h2>endpoint-location records</h2>

<pre><code>_id: username+"@"+domain (registration username)
username: string; username part of the registration username@domain
domain: string; domain part of the registration username@domain
# Information received from the client
callid: string
contact: string
cseq: integer
q: integer (-1 if none is provided by the endpoint)
user_agent: string
# Information stored by the server to manage the registration
last_modified: string (datetime, UTC)
expires: string (datetime, UTC)
received: string (IP:port from which the registration packet originated)
socket: string (IP:port on which we received the registration packet)
methods: integer
path: string
cflags: integer
flags: 0
</code></pre>

<h1>user database</h1>

<p>The user database may contain other records replicated from the user database,
the usercode database, the provisioning database.</p>

<p>The following records however are specific to an individual user database and
are not replicated.</p>

<h2>voicemail_settings record</h2>

<pre><code>_id: 'voicemail_settings'
pin: string of digits; the user's voicemail PIN [optional]
  Note: if no "pin" is specified then no authentication is required to access the voicemail box.
language: language string for this user's voicemail

email_notifications: hash; the key is the target email address; the values should be a hash containing:
  attach_message: boolean; if true the voice message is sent along with the notification

_attachments:
  prompt.wav  voicemail prompt
  name.wav    name prompt
</code></pre>

<h2>voicemail records</h2>

<pre><code>_id: type + timestamp + caller_id
type: 'voicemail'
timestamp: string; JSON timestamp e.g. "2012-02-13T14:05:21.247Z"
caller_id: string; caller_id
box: string; 'new' or 'archive'

_attachments:
  part1.wav
  part2.wav
  ...       The fragments of the message, in the order they were recorded.
</code></pre>

</div>





</div>

<div id="footer" class="pagefooter">

<div id="pageinfo">




<div id="backlinks">
Links:

<a href="../">doc</a>


</div>






<div class="pagedate">
Last edited <span class="date">Fri Mar 23 14:12:46 2012</span>
<!-- Created <span class="date">Fri Mar 23 14:12:46 2012</span> -->
</div>

</div>


<!-- from CCNQ3 -->
</div>

</div>

</body>
</html>
